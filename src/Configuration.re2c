
#include <string>
#include <iostream>

#ifndef BOOST_FILESYSTEM_VERSION
#define BOOST_FILESYSTEM_VERSION 3
#endif
#include <boost/filesystem.hpp>



#include "Configuration.h"
#include "utils.h"

const fs::path Configuration::DEFAULT_STATE_DIR = fs::current_path() / ".states";
const bool Configuration::DEFAULT_VERIFY_MODULES = true;
const std::string Configuration::VERSION = "0.1 ALPHA";
const size_t Configuration::DEFAULT_VERB_LEVEL = Verb::STD;

Configuration::Configuration(std::string const& version)
	: _version(version), _verify(DEFAULT_VERIFY_MODULES), _state_dir(DEFAULT_STATE_DIR),
		_verb(DEFAULT_VERB_LEVEL), _nullstream( ios::null_sink() )
{ /* Intentionally left blank */ }


Configuration::~Configuration()
{ /* Intentionally left blank */ }


Option::Status Configuration::load(int argc, char const** argv) {
	Option::Status ret = Option::STAT_OK;
	char const* val;
	int int_v;
	bool good;

	// Figure out who we are
	fs::path bin = argv[0];
	_bin_name = bin.filename().native();

	// parse arguments

	for (int i = 1; i < argc; i++) {
		val = NULL;

		Option::Value opt = parseOption(argv[i], val);

		switch (opt) {
		case Option::MOD_FILE:
			if (fs::native(val)) {
				_mod_file = val;
			} else {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: \"" << val << "\" is not a valid file path." << std::endl;

			}
			break;

		case Option::VERIFY:
			if (!strcmp(val, "true")) {
				_verify = true;
			} else if (!strcmp(val, "false")) {
				_verify = false;
			} else {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: unknown value provided for command line option. Expected \"true\" or \"false\" \" in \"" << opt << "\"." << std::endl;
			}
			break;

		case Option::VERBOSITY:
			good = utils::fromString(val, int_v);
			if (!good || int_v < 0) {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: unknown valud provided for command line option. Expected a non-negative integer in \"" << opt <<"." << std::endl;
			} else {
				verbosity(int_v);	
			}
			break;


		case Option::STATE_DIR:
			if (fs::native(val)) {
				_state_dir = val;
			} else {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: \"" << val << "\" is not a valid file path." << std::endl;

			}
			break;

		case Option::INPUT_FILE:
			if (fs::native(val)) {
				_input = val;
			} else {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: \"" << val << "\" is not a valid file path." << std::endl;
			}
			break;

		case Option::HELP:
			return Option::STAT_HELP;

		case Option::VERSION:
			return Option::STAT_VERSION;

		case Option::BAD:			
		default:
			ret = Option::STAT_BAD_ARG;
			std::cerr << "ERROR: Unrecognized option: \"" << argv[i] << "\"." << std::endl;
			break;
		}

	}
	return ret;
}

bool Configuration::verify() {
	bool good = true;

	if (_mod_file.empty()) {
		std::cerr << "ERROR: A module definition file is required." << std::endl;
		good = false;
	} else  if (!fs::is_regular_file(_mod_file)) {
		std::cerr << "ERROR: The provided module definition file does not exist or is not a regular file." << std::endl;
		good = false;
	}

	if (_state_dir.empty()) {
		std::cerr << "ERROR: A state-file directory is required." << std::endl;
		good = false;
	} else if (fs::exists(_state_dir) && !fs::is_directory(_state_dir)) {
		std::cerr << "ERROR: The provided state-file directory does not appear to be a directory." << std::endl;
		good = false;
	}

	if (!_input.empty() && !fs::is_regular_file(_input)) {
		good = false;
		std::cerr << "ERROR: The provided event input file does not exist or is not a regular file." << std::endl;
	}

	return good;
}

std::ostream& Configuration::ostream(Verb::Level v) {
	if (v > _verb) return _nullstream;
	else if (v == Verb::ERROR) return std::cerr;
	else return std::cout;
}

Option::Value Configuration::parseOption(char const* opt, char const*& val) {
    char const* marker;

    val = NULL;

    /*!re2c
     	re2c:define:YYCTYPE = "char";
     	re2c:define:YYCURSOR = opt;
     	re2c:yyfill:enable = 0;
    	re2c:define:YYMARKER = marker;
    	re2c:indent:top = 1;
	
		"-m="|"--modules="						{ val = opt; return Option::MOD_FILE; }
		"--verify="								{ val = opt; return Option::VERIFY; }
		"--verb="								{ val = opt; return Option::VERBOSITY; }
		"--no-verify"							{ val = "false"; return Option::VERIFY; }
		"-s="|"--state-dir="					{ val = opt; return Option::STATE_DIR; }
		"-i="|"--input="						{ val = opt; return Option::INPUT_FILE; }
		"-h"|"-?"|"--help"						{ val = NULL; return Option::HELP; }
		"-v"|"--version"						{ val = NULL; return Option::VERSION; }
		.										{ val = NULL; return Option::BAD; }
	*/

}




std::ostream& Configuration::output(std::ostream& out) const {
	out 
		<< "Executable name: " << _bin_name << std::endl
		<< "Version: " << _version << std::endl << std::endl
		<< "Module File: \"" << _mod_file.native() << "\"" << std::endl
		<< "Verify Modules: \"" << (_verify ? "true" : "false") << "\"" << std::endl
		<< "State Directory: \"" << _state_dir.native() << "\"" << std::endl
		<< "Input File: \"" << _input.native() << "\"" << std::endl
		<< "Verbosity: " << "\"" << _verb << "\"" << std::endl;

	return out;
}

std::ostream& Configuration::outputVersion(std::ostream& out) const {
	out << binaryName() << " version " << version() << std::endl;
	return out;
}

std::ostream& Configuration::outputHelp(std::ostream& out) const {
	out << "---------------------------------------------------------------------------------------"<< std::endl
		<< binaryName() << " version " << version() 												<< std::endl
		<< "---------------------------------------------------------------------------------------"<< std::endl
		<< "Usage: " << binaryName() << " -m=<MODULE_FILE> -i=<INPUT_FILE> [ADDITIONAL_OPTIONS]" 	<< std::endl
		<< "     <MODULE_FILE> - The name of the XML file containing module definitions."			<< std::endl
		<< "     <INPUT_FILE>  - The name of the file containing input events as ASP facts."		<< std::endl
		<< "     ADDITIONAL_OPTIONS:"																<< std::endl
		<< "          -s=<STATE_DIRECTORY>"															<< std::endl
		<< "          --state-dir=<STATE_DIRECTORY>"												<< std::endl
		<< "                   - Sets the directory to store the state of each module after the run"<< std::endl
		<< "                     to <STATE_DIRECTORY>. It is created if it doesn't exist."			<< std::endl
		<< "                     [Default: \".states\"]"											<< std::endl
		<< "          --verify=<true/false>"														<< std::endl
		<< "                   - Sets whether the system should verify that the modules defined by" << std::endl
		<< "                     the specified module file appear to meet the conditions imposed by"<< std::endl
		<< "                     module theorem."													<< std::endl
		<< "                     [Default: \"true\"]"												<< std::endl
		<< "          --no-verify"																	<< std::endl
		<< "                   - The same as --verify=false"										<< std::endl
		<< "          --verb=<v>"																	<< std::endl
		<< "                   - Sets the verbosity level for the application to <v>. "             << std::endl
		<< "                     Levels:"                                                           << std::endl
		<< "                        0 - Output errors only."                                        << std::endl
		<< "                        1 - Standard output [Default]."                                 << std::endl
		<< "                        2 - Output program trace information."                          << std::endl
		<< "                        3 - Output program state information."                          << std::endl
		<< std::endl
		<< "          -v"																			<< std::endl
		<< "          --version"																	<< std::endl
		<< "                   - Displays the version of this application and exits."				<< std::endl
		<< "          -h"																			<< std::endl
		<< "          --help"																		<< std::endl
		<< "                   - Displays this dialog and exits."									<< std::endl;

	return out;
}
