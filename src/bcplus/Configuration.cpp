/* Generated by re2c 0.13.5 on Wed Mar 12 13:43:24 2014 */
#line 1 "bcplus/Configuration.r2c"

#include <string>
#include <iostream>

#ifndef BOOST_FILESYSTEM_VERSION
#define BOOST_FILESYSTEM_VERSION 3
#endif
#include <boost/filesystem.hpp>
#include <boost/iostreams/device/null.hpp>

#include "babb/utils/memory.h"
#include "babb/utils/utils.h"

#include "bcplus/Configuration.h"

namespace ios = boost::iostreams;
namespace fs = boost::filesystem;

namespace bcplus {

const size_t Configuration::DEFAULT_VERB_LEVEL = Verb::STD;

Configuration::Configuration(char const* bin, char const* version)
	: _nullstream( ios::null_sink() )
{ 
	_verb = DEFAULT_VERB_LEVEL;
	_version = new ReferencedString(version);
	_bin_name = new ReferencedString(fs::path(bin).filename().native());
}


Configuration::~Configuration()
{ /* Intentionally left blank */ }


Option::Status Configuration::load(int argc, char const** argv) {
	Option::Status ret = Option::STAT_OK;
	char const* val;
	int int_v;
	bool good;

	// Figure out who we are
	fs::path bin = argv[0];
	_bin_name = new ReferencedString(bin.filename().native());

	// parse arguments

	for (int i = 1; i < argc; i++) {
		val = NULL;

		Option::Value opt = parseOption(argv[i], val);

		switch (opt) {
		case Option::SYMTAB_INPUT:
			if (fs::native(val)) {
				_symtab_in = new ReferencedPath(val);
			} else {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: \"" << val << "\" is not a valid file path." << std::endl;
			}
			break;
		case Option::SYMTAB_OUTPUT:
			if (fs::native(val)) {
				_symtab_out = new ReferencedPath(val);
			} else {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: \"" << val << "\" is not a valid file path." << std::endl;

			}
			break;

		case Option::VERBOSITY:
			good = babb::utils::fromString(val, int_v);
			if (!good || int_v < 0) {
				ret = Option::STAT_BAD_ARG;
				std::cerr << "ERROR: unknown valud provided for command line option. Expected a non-negative integer in \"" << opt <<"." << std::endl;
			} else {
				verbosity(int_v);	
			}
			break;

		case Option::HELP:
			return Option::STAT_HELP;

		case Option::VERSION:
			return Option::STAT_VERSION;

		case Option::BAD:			
		default:
			ret = Option::STAT_BAD_ARG;
			std::cerr << "ERROR: Unrecognized option: \"" << argv[i] << "\"." << std::endl;
			break;
		}

	}
	return ret;
}

bool Configuration::good() {
	bool good = true;
	// TODO
	return good;
}

std::ostream& Configuration::ostream(Verb::Level v) {
	if (v > _verb) return _nullstream;
	else if (v == Verb::ERROR) return std::cerr;
	else return std::cout;
}

Option::Value Configuration::parseOption(char const* opt, char const*& val) {
    char const* marker;

    val = NULL;

    
#line 120 "<stdout>"
	{
		char yych;

		yych = *opt;
		switch (yych) {
		case '\n':	goto yy2;
		case '-':	goto yy3;
		default:	goto yy5;
		}
yy2:
		opt = marker;
		goto yy4;
yy3:
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy6;
		case '?':
		case 'h':	goto yy9;
		case 's':	goto yy11;
		case 'v':	goto yy7;
		default:	goto yy4;
		}
yy4:
#line 128 "bcplus/Configuration.r2c"
		{ val = NULL; return Option::BAD; }
#line 146 "<stdout>"
yy5:
		yych = *++opt;
		goto yy4;
yy6:
		yych = *++opt;
		switch (yych) {
		case 'h':	goto yy16;
		case 's':	goto yy14;
		case 'v':	goto yy15;
		default:	goto yy2;
		}
yy7:
		++opt;
#line 127 "bcplus/Configuration.r2c"
		{ val = NULL; return Option::VERSION; }
#line 162 "<stdout>"
yy9:
		++opt;
#line 126 "bcplus/Configuration.r2c"
		{ val = NULL; return Option::HELP; }
#line 167 "<stdout>"
yy11:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy12;
		default:	goto yy2;
		}
yy12:
		++opt;
#line 123 "bcplus/Configuration.r2c"
		{ val = opt; return Option::SYMTAB_INPUT; }
#line 178 "<stdout>"
yy14:
		yych = *++opt;
		switch (yych) {
		case 'y':	goto yy27;
		default:	goto yy2;
		}
yy15:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy19;
		default:	goto yy2;
		}
yy16:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy17;
		default:	goto yy2;
		}
yy17:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy18;
		default:	goto yy2;
		}
yy18:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy9;
		default:	goto yy2;
		}
yy19:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy20;
		default:	goto yy2;
		}
yy20:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy22;
		case 's':	goto yy21;
		default:	goto yy2;
		}
yy21:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy25;
		default:	goto yy2;
		}
yy22:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy23;
		default:	goto yy2;
		}
yy23:
		++opt;
#line 125 "bcplus/Configuration.r2c"
		{ val = opt; return Option::VERBOSITY; }
#line 238 "<stdout>"
yy25:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy26;
		default:	goto yy2;
		}
yy26:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy7;
		default:	goto yy2;
		}
yy27:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy28;
		default:	goto yy2;
		}
yy28:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy29;
		default:	goto yy2;
		}
yy29:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy30;
		default:	goto yy2;
		}
yy30:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy31;
		default:	goto yy2;
		}
yy31:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy32;
		default:	goto yy2;
		}
yy32:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy34;
		case 'o':	goto yy33;
		default:	goto yy2;
		}
yy33:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy36;
		default:	goto yy2;
		}
yy34:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy35;
		default:	goto yy2;
		}
yy35:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy12;
		default:	goto yy2;
		}
yy36:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy37;
		default:	goto yy2;
		}
yy37:
		yych = *++opt;
		switch (yych) {
		case '=':	goto yy38;
		default:	goto yy2;
		}
yy38:
		++opt;
#line 124 "bcplus/Configuration.r2c"
		{ val = opt; return Option::SYMTAB_OUTPUT; }
#line 322 "<stdout>"
	}
#line 129 "bcplus/Configuration.r2c"


}




std::ostream& Configuration::output(std::ostream& out) const {
	out 
		<< "Executable name: " << *_bin_name << std::endl
		<< "Version: " << *_version << std::endl << std::endl
		<< "Symbol Table Input: \"" << (_symtab_in ? _symtab_in->native() : "<NONE>") << "\"" << std::endl
		<< "Symbol Table Output: \"" << (_symtab_out ? _symtab_out->native() : "<NONE>") << "\"" << std::endl
		<< "Verbosity: " << "\"" << _verb << "\"" << std::endl;

	return out;
}

std::ostream& Configuration::outputVersion(std::ostream& out) const {
	out << *binaryName() << " version " << *version() << std::endl;
	return out;
}

std::ostream& Configuration::outputHelp(std::ostream& out) const {
	out << "---------------------------------------------------------------------------------------"<< std::endl
		<< *binaryName() << " version " << *version() 												<< std::endl
		<< "---------------------------------------------------------------------------------------"<< std::endl;
	// TODO
/*
		<< "Usage: " << *binaryName() << " -m=<MODULE_FILE> -i=<INPUT_FILE> [ADDITIONAL_OPTIONS]" 	<< std::endl
		<< "     <MODULE_FILE> - The name of the XML file containing module definitions."			<< std::endl
		<< "     <INPUT_FILE>  - The name of the file containing input events as ASP facts."		<< std::endl
		<< "     ADDITIONAL_OPTIONS:"																<< std::endl
		<< "          -s=<STATE_DIRECTORY>"															<< std::endl
		<< "          --state-dir=<STATE_DIRECTORY>"												<< std::endl
		<< "                   - Sets the directory to store the state of each module after the run"<< std::endl
		<< "                     to <STATE_DIRECTORY>. It is created if it doesn't exist."			<< std::endl
		<< "                     [Default: \".states\"]"											<< std::endl
		<< "          --verify=<true/false>"														<< std::endl
		<< "                   - Sets whether the system should verify that the modules defined by" << std::endl
		<< "                     the specified module file appear to meet the conditions imposed by"<< std::endl
		<< "                     module theorem."													<< std::endl
		<< "                     [Default: \"true\"]"												<< std::endl
		<< "          --no-verify"																	<< std::endl
		<< "                   - The same as --verify=false"										<< std::endl
		<< "          --verb=<v>"																	<< std::endl
		<< "                   - Sets the verbosity level for the application to <v>. "             << std::endl
		<< "                     Levels:"                                                           << std::endl
		<< "                        0 - Output errors only."                                        << std::endl
		<< "                        1 - Standard output [Default]."                                 << std::endl
		<< "                        2 - Output program trace information."                          << std::endl
		<< "                        3 - Output program state information."                          << std::endl
		<< std::endl
		<< "          -v"																			<< std::endl
		<< "          --version"																	<< std::endl
		<< "                   - Displays the version of this application and exits."				<< std::endl
		<< "          -h"																			<< std::endl
		<< "          --help"																		<< std::endl
		<< "                   - Displays this dialog and exits."									<< std::endl;
*/
	return out;
}

};
