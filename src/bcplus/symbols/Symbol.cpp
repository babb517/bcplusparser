/* Generated by re2c 0.13.5 on Thu Mar 27 12:09:05 2014 */
#line 1 "bcplus/symbols/Symbol.r2c"
#include <string>
#include <ostream>
#include <sstream>

#include "memwrappers.h"

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp> 
#include <boost/property_tree/exceptions.hpp> 
#include <boost/algorithm/string.hpp>

#include "bcplus/symbols/Symbol.h"

namespace bcplus {
namespace symbols {

char const* Symbol::Type::cstr(type v) {
	switch (v) {
		case SORT:    			 return "sort";
        case CONSTANT: 			 return "constant";
        case VARIABLE:			 return "variable";
        case OBJECT: 			 return "object";
        case MACRO:    			 return "macro";
        case QUERY:    			 return "query";
		case ERR_INVALID_SYMBOL: return "<invalid>";
		default:				 return "<BAD_SYMBOL_TYPE>";
	}
}

Symbol::Type::type Symbol::Type::val(char const* c) {
	char const* marker;

	
#line 37 "<stdout>"
	{
		char yych;

		yych = *c;
		switch (yych) {
		case '\n':	goto yy2;
		case 'C':
		case 'c':	goto yy5;
		case 'M':
		case 'm':	goto yy8;
		case 'O':
		case 'o':	goto yy7;
		case 'Q':
		case 'q':	goto yy9;
		case 'S':
		case 's':	goto yy3;
		case 'V':
		case 'v':	goto yy6;
		default:	goto yy10;
		}
yy2:
		c = marker;
		goto yy4;
yy3:
		yych = *(marker = ++c);
		switch (yych) {
		case 'O':
		case 'o':	goto yy43;
		default:	goto yy4;
		}
yy4:
#line 46 "bcplus/symbols/Symbol.r2c"
		{ return ERR_INVALID_SYMBOL; }
#line 71 "<stdout>"
yy5:
		yych = *(marker = ++c);
		switch (yych) {
		case 'O':
		case 'o':	goto yy35;
		default:	goto yy4;
		}
yy6:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy27;
		default:	goto yy4;
		}
yy7:
		yych = *(marker = ++c);
		switch (yych) {
		case 'B':
		case 'b':	goto yy21;
		default:	goto yy4;
		}
yy8:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy16;
		default:	goto yy4;
		}
yy9:
		yych = *(marker = ++c);
		switch (yych) {
		case 'U':
		case 'u':	goto yy11;
		default:	goto yy4;
		}
yy10:
		yych = *++c;
		goto yy4;
yy11:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy12;
		default:	goto yy2;
		}
yy12:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy13;
		default:	goto yy2;
		}
yy13:
		yych = *++c;
		switch (yych) {
		case 'Y':
		case 'y':	goto yy14;
		default:	goto yy2;
		}
yy14:
		++c;
#line 45 "bcplus/symbols/Symbol.r2c"
		{ return QUERY; }
#line 135 "<stdout>"
yy16:
		yych = *++c;
		switch (yych) {
		case 'C':
		case 'c':	goto yy17;
		default:	goto yy2;
		}
yy17:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy18;
		default:	goto yy2;
		}
yy18:
		yych = *++c;
		switch (yych) {
		case 'O':
		case 'o':	goto yy19;
		default:	goto yy2;
		}
yy19:
		++c;
#line 44 "bcplus/symbols/Symbol.r2c"
		{ return MACRO; }
#line 161 "<stdout>"
yy21:
		yych = *++c;
		switch (yych) {
		case 'J':
		case 'j':	goto yy22;
		default:	goto yy2;
		}
yy22:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy23;
		default:	goto yy2;
		}
yy23:
		yych = *++c;
		switch (yych) {
		case 'C':
		case 'c':	goto yy24;
		default:	goto yy2;
		}
yy24:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy25;
		default:	goto yy2;
		}
yy25:
		++c;
#line 43 "bcplus/symbols/Symbol.r2c"
		{ return OBJECT; }
#line 194 "<stdout>"
yy27:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy28;
		default:	goto yy2;
		}
yy28:
		yych = *++c;
		switch (yych) {
		case 'I':
		case 'i':	goto yy29;
		default:	goto yy2;
		}
yy29:
		yych = *++c;
		switch (yych) {
		case 'A':
		case 'a':	goto yy30;
		default:	goto yy2;
		}
yy30:
		yych = *++c;
		switch (yych) {
		case 'B':
		case 'b':	goto yy31;
		default:	goto yy2;
		}
yy31:
		yych = *++c;
		switch (yych) {
		case 'L':
		case 'l':	goto yy32;
		default:	goto yy2;
		}
yy32:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy33;
		default:	goto yy2;
		}
yy33:
		++c;
#line 42 "bcplus/symbols/Symbol.r2c"
		{ return VARIABLE; }
#line 241 "<stdout>"
yy35:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy36;
		default:	goto yy2;
		}
yy36:
		yych = *++c;
		switch (yych) {
		case 'S':
		case 's':	goto yy37;
		default:	goto yy2;
		}
yy37:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy38;
		default:	goto yy2;
		}
yy38:
		yych = *++c;
		switch (yych) {
		case 'A':
		case 'a':	goto yy39;
		default:	goto yy2;
		}
yy39:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy40;
		default:	goto yy2;
		}
yy40:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy41;
		default:	goto yy2;
		}
yy41:
		++c;
#line 41 "bcplus/symbols/Symbol.r2c"
		{ return CONSTANT; }
#line 288 "<stdout>"
yy43:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy44;
		default:	goto yy2;
		}
yy44:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy45;
		default:	goto yy2;
		}
yy45:
		++c;
#line 40 "bcplus/symbols/Symbol.r2c"
		{ return SORT; }
#line 307 "<stdout>"
	}
#line 47 "bcplus/symbols/Symbol.r2c"

}

std::string Symbol::genName(std::string const& base, size_t arity) {
	return base + "/" + boost::lexical_cast<std::string>(arity);
}


Symbol::Symbol(Type::type type, ReferencedString const* base, size_t arity)
	: _type(type), _arity(arity), _base(base), _good(true) {
	_name = new ReferencedString(genName(*base, arity)); 
	_metadata = NULL;
}

Symbol::Symbol(Type::type type, boost::property_tree::ptree const& node, std::ostream* err) {
	bool good = true;

	try {
		std::string base = node.get("<xmlattr>.name","");
		int arity = node.get("<xmlattr>.arity",0);
	
		if (base == "") {
			good = false;
			if (err) *err << "Error: Encountered malformed symbol declaration. Expected a 'base' attribute." << std::endl;
		}

		if (arity < 0) {
			good = false;
			if (err) *err << "Error: Encountered malformed symbol declaration. Expected an non-negative integer 'arity' attribute." << std::endl;
		}
	
		_type = type;
		_arity = (size_t)arity;
		_base = new ReferencedString(base);
		
		_name = new ReferencedString(genName(base, arity));
	} catch (boost::property_tree::ptree_error const& e) {
		good = false;
		if (err) *err << "Error: Encountered malformed symbol declaration. Expected an non-negative integer 'arity' attribute." << std::endl;
	}


	_good = good;
	_metadata = NULL;
}

Symbol::~Symbol() {
	/* Intentionally left blank */
}

bool Symbol::operator==(Symbol const& other) const {
	if (!good() || !other.good()) return false;
	if (type() != other.type()) return false;
	if (arity() != other.arity()) return false;
	if (*base() != *(other.base())) return false;
	return true;
}

void Symbol::save(boost::property_tree::ptree& node) const {
	node.put("<xmlattr>.base", *base());
	if (arity()) node.put("<xmlattr>.arity", arity());
}


}}
