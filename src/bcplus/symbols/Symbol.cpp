/* Generated by re2c 0.13.5 on Thu Mar 13 17:42:46 2014 */
#line 1 "bcplus/symbols/Symbol.r2c"
#include <string>
#include <ostream>
#include <sstream>

#include "memwrappers.h"

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp> 
#include <boost/algorithm/string.hpp>

#include "bcplus/symbols/Symbol.h"

namespace bcplus {
namespace symbols {

char const* Symbol::Type::cstr(Value v) {
	switch (v) {
		case SORT:    			 return "sort";
        case CONSTANT: 			 return "constant";
        case VARIABLE:			 return "variable";
        case OBJECT: 			 return "object";
        case MACRO:    			 return "macro";
		case ERR_INVALID_SYMBOL: return "<invalid>";
		default:				 return "<BAD_SYMBOL_TYPE>";
	}
}

Symbol::Type::Value Symbol::Type::val(char const* c) {
	char const* marker;

	
#line 35 "<stdout>"
	{
		char yych;

		yych = *c;
		switch (yych) {
		case '\n':	goto yy2;
		case 'C':
		case 'c':	goto yy5;
		case 'M':
		case 'm':	goto yy8;
		case 'O':
		case 'o':	goto yy7;
		case 'S':
		case 's':	goto yy3;
		case 'V':
		case 'v':	goto yy6;
		default:	goto yy9;
		}
yy2:
		c = marker;
		goto yy4;
yy3:
		yych = *(marker = ++c);
		switch (yych) {
		case 'O':
		case 'o':	goto yy37;
		default:	goto yy4;
		}
yy4:
#line 43 "bcplus/symbols/Symbol.r2c"
		{ return ERR_INVALID_SYMBOL; }
#line 67 "<stdout>"
yy5:
		yych = *(marker = ++c);
		switch (yych) {
		case 'O':
		case 'o':	goto yy29;
		default:	goto yy4;
		}
yy6:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy21;
		default:	goto yy4;
		}
yy7:
		yych = *(marker = ++c);
		switch (yych) {
		case 'B':
		case 'b':	goto yy15;
		default:	goto yy4;
		}
yy8:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy10;
		default:	goto yy4;
		}
yy9:
		yych = *++c;
		goto yy4;
yy10:
		yych = *++c;
		switch (yych) {
		case 'C':
		case 'c':	goto yy11;
		default:	goto yy2;
		}
yy11:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy12;
		default:	goto yy2;
		}
yy12:
		yych = *++c;
		switch (yych) {
		case 'O':
		case 'o':	goto yy13;
		default:	goto yy2;
		}
yy13:
		++c;
#line 42 "bcplus/symbols/Symbol.r2c"
		{ return MACRO; }
#line 124 "<stdout>"
yy15:
		yych = *++c;
		switch (yych) {
		case 'J':
		case 'j':	goto yy16;
		default:	goto yy2;
		}
yy16:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy17;
		default:	goto yy2;
		}
yy17:
		yych = *++c;
		switch (yych) {
		case 'C':
		case 'c':	goto yy18;
		default:	goto yy2;
		}
yy18:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy19;
		default:	goto yy2;
		}
yy19:
		++c;
#line 41 "bcplus/symbols/Symbol.r2c"
		{ return OBJECT; }
#line 157 "<stdout>"
yy21:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy22;
		default:	goto yy2;
		}
yy22:
		yych = *++c;
		switch (yych) {
		case 'I':
		case 'i':	goto yy23;
		default:	goto yy2;
		}
yy23:
		yych = *++c;
		switch (yych) {
		case 'A':
		case 'a':	goto yy24;
		default:	goto yy2;
		}
yy24:
		yych = *++c;
		switch (yych) {
		case 'B':
		case 'b':	goto yy25;
		default:	goto yy2;
		}
yy25:
		yych = *++c;
		switch (yych) {
		case 'L':
		case 'l':	goto yy26;
		default:	goto yy2;
		}
yy26:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy27;
		default:	goto yy2;
		}
yy27:
		++c;
#line 40 "bcplus/symbols/Symbol.r2c"
		{ return VARIABLE; }
#line 204 "<stdout>"
yy29:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy30;
		default:	goto yy2;
		}
yy30:
		yych = *++c;
		switch (yych) {
		case 'S':
		case 's':	goto yy31;
		default:	goto yy2;
		}
yy31:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy32;
		default:	goto yy2;
		}
yy32:
		yych = *++c;
		switch (yych) {
		case 'A':
		case 'a':	goto yy33;
		default:	goto yy2;
		}
yy33:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy34;
		default:	goto yy2;
		}
yy34:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy35;
		default:	goto yy2;
		}
yy35:
		++c;
#line 39 "bcplus/symbols/Symbol.r2c"
		{ return CONSTANT; }
#line 251 "<stdout>"
yy37:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy38;
		default:	goto yy2;
		}
yy38:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy39;
		default:	goto yy2;
		}
yy39:
		++c;
#line 38 "bcplus/symbols/Symbol.r2c"
		{ return SORT; }
#line 270 "<stdout>"
	}
#line 44 "bcplus/symbols/Symbol.r2c"

}

std::string Symbol::genName(std::string const& base, size_t arity) {
	return base + "/" + boost::lexical_cast<std::string>(arity);
}


Symbol::Symbol(Type::Value type, ReferencedString const* base, size_t arity)
	: _type(type), _arity(arity), _base(base), _good(true) {
	_name = new ReferencedString(genName(*base, arity)); 
}

Symbol::Symbol(Type::Value type, boost::property_tree::ptree const& node, std::ostream* err) {
	bool good = true;
	std::string base = node.get("<xmlattr>.name","");
	int arity = node.get("<xmlattr>.arity",0);

	if (base == "") {
		good = false;
		if (err) *err << "Error: Encountered malformed symbol declaration. Expected a 'base' attribute." << std::endl;
	}

	if (arity < 0) {
		good = false;
		if (err) *err << "Error: Encountered malformed symbol declaration. Expected an non-negative integer 'arity' attribute." << std::endl;
	}

	_type = type;
	_arity = (size_t)arity;
	_base = new ReferencedString(base);
	
	_name = new ReferencedString(genName(base, arity));

	_good = good;
}

Symbol::~Symbol() {
	/// Intentionally left blank
}

bool Symbol::operator==(Symbol const& other) const {
	if (!good() || !other.good()) return false;
	if (type() != other.type()) return false;
	if (arity() != other.arity()) return false;
	if (*base() != *(other.base())) return false;
	return true;
}

void Symbol::save(boost::property_tree::ptree& node) const {
	node.put("<xmlattr>.base", *base());
	if (arity()) node.put("<xmlattr>.arity", arity());
}


}}
