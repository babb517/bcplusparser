/* Generated by re2c 0.13.6 on Mon May  5 23:51:11 2014 */
#line 1 "bcplus/parser/detail/Scanner.1.re2c"

#include <sstream>

#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include "bcplus/parser/detail/Scanner.h"
#include "bcplus/parser/detail/lemon_parser.h"

#include "bcplus/Location.h"
#include "bcplus/parser/Token.h"

#include "bcplus/parser/detail/ScannerSource.h"
#include "bcplus/parser/detail/ScannerRawSource.h"
#include "bcplus/parser/detail/ScannerTokenSource.h"
#include "bcplus/parser/detail/ScannerFileSource.h"
#include "bcplus/parser/detail/ScannerBufferSource.h"

namespace u = babb::utils; 
namespace fs = boost::filesystem;

namespace bcplus {
namespace parser {
namespace detail {

Scanner::Scanner(Configuration const* config)
	: _cond(yycNORMAL), _config(config), _in_macro(false) {
	// Intentionally left blank
}

Scanner::~Scanner() {
	// Intentionally left blank
}

bool Scanner::push_front(fs::path const& file, bool squelch) {
	u::ref_ptr<ScannerFileSource> src = new ScannerFileSource(_config, file, squelch);
	if (!src->good()) return false;
	_sources.push_front(src.get());
	return true;
}

bool Scanner::push_back(fs::path const& file, bool squelch) {
	u::ref_ptr<ScannerFileSource> src = new ScannerFileSource(_config, file, squelch);
	if (!src->good()) return false;
	_sources.push_back(src.get());
	return true;
}

void Scanner::push_front(char const* buffer, Location const& loc, bool track_position) {
	u::ref_ptr<ScannerBufferSource> src = new ScannerBufferSource(_config, buffer, loc, track_position);
	_sources.push_front(src.get());
}

void Scanner::push_back(char const* buffer, Location const& loc, bool track_position) {
	u::ref_ptr<ScannerBufferSource> src = new ScannerBufferSource(_config, buffer, loc, track_position);
	_sources.push_back(src.get());
}

void Scanner::push_back(Token* token) {
	if (!_sources.size() || _sources.back()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_back(new ScannerTokenSource(token));
	} else ((ScannerTokenSource*)_sources.back().get())->push_back(token);
}

void Scanner::push_front(Token* token) {
	if (!_sources.size() || _sources.front()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_front(new ScannerTokenSource(token));
	} else ((ScannerTokenSource*)_sources.front().get())->push_front(token);
}

void Scanner::push_back(TokenList* tokens) {
	if (!_sources.size() || _sources.back()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_back(new ScannerTokenSource(tokens));
	} else ((ScannerTokenSource*)_sources.back().get())->push_back(tokens);
}

void Scanner::push_front(TokenList* tokens) {
	if (!_sources.size() || _sources.front()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_front(new ScannerTokenSource(tokens));
	} else ((ScannerTokenSource*)_sources.front().get())->push_front(tokens);
}


Token* Scanner::readToken() {
	u::ref_ptr<Token> token = NULL;
	if (!size()) {
		Location l = loc();
		token  = new Token(T_EOF, new ReferencedString("<EOF>"), l, l);
	} else {
		do {
			ScannerSource* src = _sources.front();
#ifndef NDEBUG
			_config->ostream(Verb::TRACE_SCANNER) << "TRACE: " << size() << " sources, reading from \"" 
				<< (src->loc().file() ? src->loc().file()->native() : std::string("<NULL>")) << "\"." << std::endl;
#endif
			switch(src->type()) {
			case ScannerSource::Type::RAW:
				token = tokenize((ScannerRawSource*)src);
				break;
			case ScannerSource::Type::TOKENS:
				token = ((ScannerTokenSource*)src)->next();
				break;
			}
	
			if (!token || token->type() == T_ERR_IO) {
#ifndef NDEBUG
				_config->ostream(Verb::TRACE_SCANNER) << "TRACE: Scanner encountered IO error." << std::endl;
#endif
				_sources.pop_front();
			} else if (token->type() == T_EOF) {
#ifndef NDEBUG
				_config->ostream(Verb::TRACE_SCANNER) << "TRACE: Scanner encountered end of input source." << std::endl;
#endif
				_sources.pop_front();
			}
		} while (token && token->type() == T_EOF && size());
	}
	
	if (!token) {
		Location l = loc();
#ifndef NDEBUG
		_config->ostream(Verb::TRACE_SCANNER) << "TRACE: Scanner got a null token." << std::endl;
#endif
		token  = new Token(T_ERR_IO, new ReferencedString("<IO ERROR>"), l, l);
	}

#ifndef NDEBUG
	_config->ostream(Verb::TRACE_SCANNER) << "TRACE: " << token->beginLoc() << ": (" << token->typeString() << "): \"" << *token << "\": Read from scanner." << std::endl;
#endif

	return token.release();
}

#define BLK_INIT(s) \
	blk.str(s); \
	use_blk = true; \
	source->token() = source->cursor() + 1;

#define BLK_LINE \
	source->newline(); \
    blk.write(source->token(), (size_t)(source->cursor() - source->token())); \
	source->token() = source->cursor() + 1;		

#define BLK_FINISH(sz) \
	blk.write(source->token(), (size_t)(source->cursor() - source->token() - sz));

Token* Scanner::tokenize(ScannerRawSource* source) {
	if (source->eof()) return new Token(T_EOF, new ReferencedString("<EOF>"), source->loc(), source->loc());
	else if (!source->good()) return new Token(T_ERR_IO, new ReferencedString("<IO ERROR>"), source->loc(), source->loc());


	std::stringstream blk;
	int ret;
	Location begin;
	bool use_blk = false;
	size_t preskip = 0;
	size_t postskip = 0;

re2c_start:
	source->token() = source->cursor();
	begin = source->loc();

	if (_cond == yycNORMAL) {
	
#line 168 "<stdout>"
{
	char yych;
	if (_cond < 6) {
		if (_cond < 3) {
			if (_cond < 1) {
				goto yyc_NORMAL;
			} else {
				if (_cond < 2) {
					goto yyc_ARG;
				} else {
					goto yyc_ASP_CP;
				}
			}
		} else {
			if (_cond < 4) {
				goto yyc_ASP_GR;
			} else {
				if (_cond < 5) {
					goto yyc_DBL_STRING;
				} else {
					goto yyc_F2LP_CP;
				}
			}
		}
	} else {
		if (_cond < 9) {
			if (_cond < 7) {
				goto yyc_F2LP_GR;
			} else {
				if (_cond < 8) {
					goto yyc_LUA_CP;
				} else {
					goto yyc_LUA_GR;
				}
			}
		} else {
			if (_cond < 11) {
				if (_cond < 10) {
					goto yyc_MACO;
				} else {
					goto yyc_SG_STRING;
				}
			} else {
				if (_cond < 12) {
					goto yyc_COMMENT;
				} else {
					goto yyc_BLK_COMMENT;
				}
			}
		}
	}
/* *********************************** */
yyc_ARG:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_4;
yy1_4:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 231 "<stdout>"
/* *********************************** */
yyc_ASP_CP:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_9;
yy1_9:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 243 "<stdout>"
/* *********************************** */
yyc_ASP_GR:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_14;
yy1_14:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 255 "<stdout>"
/* *********************************** */
yyc_BLK_COMMENT:
	if ((source->limit() - source->cursor()) < 2) source->fill(2);
	yych = *source->cursor();
	if (yych <= '\n') {
		if (yych <= 0x00) goto yy1_18;
		if (yych <= '\t') goto yy1_20;
		goto yy1_23;
	} else {
		if (yych == '*') goto yy1_22;
		goto yy1_20;
	}
yy1_18:
	++source->cursor();
#line 221 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  BLK_FINISH(1);
												  ret = T_ERR_UNTERMINATED_BLK_COMMENT;			
												  _cond = yycNORMAL;
												  source->cursor()--;
												  goto re2c_finish;					
												}
#line 278 "<stdout>"
yy1_20:
	++source->cursor();
yy1_21:
#line 228 "bcplus/parser/detail/Scanner.1.re2c"
	{												goto yyc_BLK_COMMENT;				}
#line 284 "<stdout>"
yy1_22:
	yych = *++source->cursor();
	if (yych == '/') goto yy1_25;
	goto yy1_21;
yy1_23:
	++source->cursor();
#line 210 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  BLK_LINE;
												  blk << "% "; 
												  goto yyc_BLK_COMMENT;				
												}
#line 297 "<stdout>"
yy1_25:
	++source->cursor();
#line 215 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  BLK_FINISH(2);
												  _cond = yycNORMAL; 
												  ret = T_COMMENT; 
												  goto re2c_finish;					
												}
#line 307 "<stdout>"
/* *********************************** */
yyc_COMMENT:
	{
		static const unsigned char yybm[] = {
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128,   0, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
		};
		if ((source->limit() - source->cursor()) < 2) source->fill(2);
		yych = *source->cursor();
		if (yych <= 0x00) goto yy1_29;
		if (yych == '\n') goto yy1_32;
		goto yy1_31;
yy1_29:
		++source->cursor();
		yych = *source->cursor();
		goto yy1_35;
yy1_30:
#line 202 "bcplus/parser/detail/Scanner.1.re2c"
		{ 												goto yyc_COMMENT;					}
#line 357 "<stdout>"
yy1_31:
		yych = *++source->cursor();
		goto yy1_35;
yy1_32:
		++source->cursor();
#line 196 "bcplus/parser/detail/Scanner.1.re2c"
		{ 
												  source->cursor()--; 
												  _cond = yycNORMAL; 
												  ret = T_COMMENT;			
												  goto re2c_finish;
												}
#line 370 "<stdout>"
yy1_34:
		++source->cursor();
		if (source->limit() <= source->cursor()) source->fill(1);
		yych = *source->cursor();
yy1_35:
		if (yybm[0+yych] & 128) {
			goto yy1_34;
		}
		goto yy1_30;
	}
/* *********************************** */
yyc_DBL_STRING:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_39;
yy1_39:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 392 "<stdout>"
/* *********************************** */
yyc_F2LP_CP:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_44;
yy1_44:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 404 "<stdout>"
/* *********************************** */
yyc_F2LP_GR:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_49;
yy1_49:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 416 "<stdout>"
/* *********************************** */
yyc_LUA_CP:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_54;
yy1_54:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 428 "<stdout>"
/* *********************************** */
yyc_LUA_GR:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_59;
yy1_59:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 440 "<stdout>"
/* *********************************** */
yyc_MACO:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_64;
yy1_64:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 452 "<stdout>"
/* *********************************** */
yyc_NORMAL:
	if ((source->limit() - source->cursor()) < 2) source->fill(2);
	yych = *source->cursor();
	if (yych <= 0x1F) {
		if (yych <= '\t') {
			if (yych <= 0x00) goto yy1_68;
			if (yych <= 0x08) goto yy1_70;
			goto yy1_72;
		} else {
			if (yych <= '\n') goto yy1_77;
			if (yych <= '\f') goto yy1_72;
			goto yy1_70;
		}
	} else {
		if (yych <= '%') {
			if (yych <= ' ') goto yy1_72;
			if (yych <= '$') goto yy1_70;
			goto yy1_74;
		} else {
			if (yych == '/') goto yy1_76;
			goto yy1_70;
		}
	}
yy1_68:
	++source->cursor();
#line 182 "bcplus/parser/detail/Scanner.1.re2c"
	{ ret = T_EOF; 							goto re2c_finish; 					}
#line 481 "<stdout>"
yy1_70:
	++source->cursor();
yy1_71:
#line 230 "bcplus/parser/detail/Scanner.1.re2c"
	{ goto re2c_notcmt; }
#line 487 "<stdout>"
yy1_72:
	++source->cursor();
#line 181 "bcplus/parser/detail/Scanner.1.re2c"
	{ 										goto re2c_start; 					}
#line 492 "<stdout>"
yy1_74:
	++source->cursor();
#line 184 "bcplus/parser/detail/Scanner.1.re2c"
	{ _cond = yycCOMMENT; 							goto yyc_COMMENT;	 				}
#line 497 "<stdout>"
yy1_76:
	yych = *++source->cursor();
	if (yych == '*') goto yy1_79;
	goto yy1_71;
yy1_77:
	++source->cursor();
#line 180 "bcplus/parser/detail/Scanner.1.re2c"
	{ source->newline();		 			goto re2c_start; 					}
#line 506 "<stdout>"
yy1_79:
	++source->cursor();
#line 185 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  _cond = yycBLK_COMMENT; 
												  BLK_INIT("% ");
												  goto yyc_BLK_COMMENT; 				
												}
#line 515 "<stdout>"
/* *********************************** */
yyc_SG_STRING:
	if (source->limit() <= source->cursor()) source->fill(1);
	yych = *source->cursor();
	if (yych != '\n') goto yy1_84;
yy1_84:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{
												  goto re2c_notcmt;
												}
#line 527 "<stdout>"
}
#line 231 "bcplus/parser/detail/Scanner.1.re2c"

	}
re2c_notcmt:
	source->cursor() = source->token();
	return tokenize_2(source);

re2c_finish:
	u::ref_ptr<ReferencedString> str = new ReferencedString();
	if (ret != T_EOF) {
		if (use_blk)
			str->assign(blk.str());
		else
			str->assign(source->token() + preskip, (size_t)(source->cursor() - source->token() - preskip - postskip));
	} else {
		str->assign("<EOF>");
	}

	return new Token(ret, str, begin, source->loc());
}

void Scanner::close() {
	_sources.clear();
}



}}}
