/* Generated by re2c 0.13.6 on Wed Apr 23 22:21:42 2014 */
#line 1 "bcplus/parser/detail/Scanner.1.re2c"

#include <sstream>

#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include "bcplus/parser/detail/Scanner.h"
#include "bcplus/parser/detail/lemon_parser.h"

#include "bcplus/Location.h"
#include "bcplus/parser/Token.h"

#include "bcplus/parser/detail/ScannerSource.h"
#include "bcplus/parser/detail/ScannerRawSource.h"
#include "bcplus/parser/detail/ScannerTokenSource.h"
#include "bcplus/parser/detail/ScannerFileSource.h"
#include "bcplus/parser/detail/ScannerBufferSource.h"

namespace u = babb::utils; 
namespace fs = boost::filesystem;

namespace bcplus {
namespace parser {
namespace detail {

Scanner::Scanner(Configuration const* config)
	: _cond(yycNORMAL), _config(config), _in_macro(false) {
	// Intentionally left blank
}

Scanner::~Scanner() {
	// Intentionally left blank
}

bool Scanner::push_front(fs::path const& file, bool squelch) {
	u::ref_ptr<ScannerFileSource> src = new ScannerFileSource(_config, file, squelch);
	if (!src->good()) return false;
	_sources.push_front(src.get());
	return true;
}

bool Scanner::push_back(fs::path const& file, bool squelch) {
	u::ref_ptr<ScannerFileSource> src = new ScannerFileSource(_config, file, squelch);
	if (!src->good()) return false;
	_sources.push_back(src.get());
	return true;
}

void Scanner::push_front(char const* buffer, Location const& loc, bool track_position) {
	u::ref_ptr<ScannerBufferSource> src = new ScannerBufferSource(_config, buffer, loc, track_position);
	_sources.push_front(src.get());
}

void Scanner::push_back(char const* buffer, Location const& loc, bool track_position) {
	u::ref_ptr<ScannerBufferSource> src = new ScannerBufferSource(_config, buffer, loc, track_position);
	_sources.push_back(src.get());
}

void Scanner::push_back(Token* token) {
	if (!_sources.size() || _sources.back()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_back(new ScannerTokenSource(token));
	} else ((ScannerTokenSource*)_sources.back().get())->push_back(token);
}

void Scanner::push_front(Token* token) {
	if (!_sources.size() || _sources.front()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_front(new ScannerTokenSource(token));
	} else ((ScannerTokenSource*)_sources.front().get())->push_front(token);
}

void Scanner::push_back(TokenList* tokens) {
	if (!_sources.size() || _sources.back()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_back(new ScannerTokenSource(tokens));
	} else ((ScannerTokenSource*)_sources.back().get())->push_back(tokens);
}

void Scanner::push_front(TokenList* tokens) {
	if (!_sources.size() || _sources.front()->type() != ScannerSource::Type::TOKENS) {
		_sources.push_front(new ScannerTokenSource(tokens));
	} else ((ScannerTokenSource*)_sources.front().get())->push_front(tokens);
}


Token* Scanner::readToken() {
	u::ref_ptr<Token> token = NULL;
	if (!size()) {
		Location l = loc();
		token  = new Token(T_EOF, new ReferencedString("<EOF>"), l, l);
	} else {
		do {
			ScannerSource* src = _sources.front();
#ifndef NDEBUG
			_config->ostream(Verb::TRACE_SCANNER) << "TRACE: " << size() << " sources, reading from \"" 
				<< (src->loc().file() ? src->loc().file()->native() : std::string("<NULL>")) << "\"." << std::endl;
#endif
			switch(src->type()) {
			case ScannerSource::Type::RAW:
				token = tokenize((ScannerRawSource*)src);
				break;
			case ScannerSource::Type::TOKENS:
				token = ((ScannerTokenSource*)src)->next();
				break;
			}
	
			if (!token || token->type() == T_ERR_IO) {
#ifndef NDEBUG
				_config->ostream(Verb::TRACE_SCANNER) << "TRACE: Scanner encountered IO error." << std::endl;
#endif
				_sources.pop_front();
			} else if (token->type() == T_EOF) {
#ifndef NDEBUG
				_config->ostream(Verb::TRACE_SCANNER) << "TRACE: Scanner encountered end of input source." << std::endl;
#endif
				_sources.pop_front();
			}
		} while (token && token->type() == T_EOF && size());
	}
	
	if (!token) {
		Location l = loc();
#ifndef NDEBUG
		_config->ostream(Verb::TRACE_SCANNER) << "TRACE: Scanner got a null token." << std::endl;
#endif
		token  = new Token(T_ERR_IO, new ReferencedString("<IO ERROR>"), l, l);
	}

#ifndef NDEBUG
	_config->ostream(Verb::TRACE_SCANNER) << "TRACE: " << token->beginLoc() << ": (" << token->typeString() << "): \"" << *token << "\": Read from scanner." << std::endl;
#endif

	return token.release();
}

#define BLK_INIT(s) \
	blk.str(s); \
	use_blk = true; \
	source->token() = source->cursor() + 1;

#define BLK_LINE \
	source->newline(); \
    blk.write(source->token(), (size_t)(source->cursor() - source->token())); \
	source->token() = source->cursor() + 1;		

#define BLK_FINISH(sz) \
	blk.write(source->token(), (size_t)(source->cursor() - source->token() - sz));

Token* Scanner::tokenize(ScannerRawSource* source) {
	if (source->eof()) return new Token(T_EOF, new ReferencedString("<EOF>"), source->loc(), source->loc());
	else if (!source->good()) return new Token(T_ERR_IO, new ReferencedString("<IO ERROR>"), source->loc(), source->loc());


	std::stringstream blk;
	int ret;
	Location begin;
	bool use_blk = false;
	size_t preskip = 0;
	size_t postskip = 0;

	int parens = 0;

	char const* marker;

re2c_start:
	marker = source->token() = source->cursor();
	begin = source->loc();

	YYCONDTYPE cond = yycNORMAL;	

	
#line 173 "<stdout>"
{
	char yych;
	if (cond < 1) {
		goto yyc_NORMAL;
	} else {
		if (cond < 2) {
			goto yyc_COMMENT;
		} else {
			goto yyc_BLK_COMMENT;
		}
	}
/* *********************************** */
yyc_BLK_COMMENT:
	if ((source->limit() - source->cursor()) < 2) source->fill(2);
	yych = *source->cursor();
	if (yych <= '\n') {
		if (yych <= 0x00) goto yyy3;
		if (yych <= '\t') goto yyy5;
		goto yyy8;
	} else {
		if (yych == '*') goto yyy7;
		goto yyy5;
	}
yyy3:
	++source->cursor();
#line 223 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  BLK_FINISH(1);
												  ret = T_ERR_UNTERMINATED_BLK_COMMENT;			
												  cond = yycNORMAL;
												  source->cursor()--;
												  goto re2c_finish;					
												}
#line 207 "<stdout>"
yyy5:
	++source->cursor();
yyy6:
#line 230 "bcplus/parser/detail/Scanner.1.re2c"
	{												goto yyc_BLK_COMMENT;				}
#line 213 "<stdout>"
yyy7:
	yych = *++source->cursor();
	if (yych == '/') goto yyy10;
	goto yyy6;
yyy8:
	++source->cursor();
#line 212 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  BLK_LINE;
												  blk << "% "; 
												  goto yyc_BLK_COMMENT;				
												}
#line 226 "<stdout>"
yyy10:
	++source->cursor();
#line 217 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  BLK_FINISH(2);
												  cond = yycNORMAL; 
												  ret = T_COMMENT; 
												  goto re2c_finish;					
												}
#line 236 "<stdout>"
/* *********************************** */
yyc_COMMENT:
	{
		static const unsigned char yybm[] = {
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128,   0, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
			128, 128, 128, 128, 128, 128, 128, 128, 
		};
		if ((source->limit() - source->cursor()) < 2) source->fill(2);
		yych = *source->cursor();
		if (yych <= 0x00) goto yyy14;
		if (yych == '\n') goto yyy17;
		goto yyy16;
yyy14:
		++source->cursor();
		yych = *source->cursor();
		goto yyy20;
yyy15:
#line 204 "bcplus/parser/detail/Scanner.1.re2c"
		{ 												goto yyc_COMMENT;					}
#line 286 "<stdout>"
yyy16:
		yych = *++source->cursor();
		goto yyy20;
yyy17:
		++source->cursor();
#line 198 "bcplus/parser/detail/Scanner.1.re2c"
		{ 
												  source->cursor()--; 
												  cond = yycNORMAL; 
												  ret = T_COMMENT;			
												  goto re2c_finish;
												}
#line 299 "<stdout>"
yyy19:
		++source->cursor();
		if (source->limit() <= source->cursor()) source->fill(1);
		yych = *source->cursor();
yyy20:
		if (yybm[0+yych] & 128) {
			goto yyy19;
		}
		goto yyy15;
	}
/* *********************************** */
yyc_NORMAL:
	if ((source->limit() - source->cursor()) < 2) source->fill(2);
	yych = *source->cursor();
	if (yych <= '$') {
		if (yych != '\n') goto yyy24;
	} else {
		if (yych <= '%') goto yyy26;
		if (yych == '/') goto yyy28;
		goto yyy24;
	}
yyy24:
	++source->cursor();
yyy25:
#line 232 "bcplus/parser/detail/Scanner.1.re2c"
	{ goto re2c_notcmt; }
#line 326 "<stdout>"
yyy26:
	++source->cursor();
#line 192 "bcplus/parser/detail/Scanner.1.re2c"
	{ cond = yycCOMMENT; 							goto yyc_COMMENT;	 				}
#line 331 "<stdout>"
yyy28:
	yych = *++source->cursor();
	if (yych != '*') goto yyy25;
	++source->cursor();
#line 193 "bcplus/parser/detail/Scanner.1.re2c"
	{ 
												  cond = yycBLK_COMMENT; 
												  BLK_INIT("% ");
												  goto yyc_BLK_COMMENT; 				
												}
#line 342 "<stdout>"
}
#line 233 "bcplus/parser/detail/Scanner.1.re2c"

re2c_notcmt:
	source->cursor() = source->token();
	return tokenize_2(source);

re2c_finish:
	u::ref_ptr<ReferencedString> str = new ReferencedString();
	if (ret != T_EOF) {
		if (use_blk)
			str->assign(blk.str());
		else
			str->assign(source->token() + preskip, (size_t)(source->cursor() - source->token() - preskip - postskip));
	} else {
		str->assign("<EOF>");
	}

	return new Token(ret, str, begin, source->loc());
}

void Scanner::close() {
	_sources.clear();
}



}}}
