
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include "parser/Scanner.h"
#include "parser/atom_parser.h"

#include "parser/Location.h"
#include "parser/Token.h"

#include "parser/detail/ScannerSource.h"
#include "parser/detail/ScannerFileSource.h"
#include "parser/detail/ScannerBufferSource.h"

namespace fs = boost::filesystem;

namespace bcplus {
namespace parser {
namespace detail {

Scanner::Scanner(Configuration* config)
	: _cond(yycNORMAL), _lasttoken()(NULL), _config(config) {
	// Intentionally left blank
}

Scanner::~Scanner() {
	// Intentionally left blank
}

bool Scanner::push_front(fs::path const& file, bool squelch) {
	ref_ptr<ScannerFileSource> src = new ScannerFileSource(_config, file, squelch);
	if (!src->good()) return false;
	_sources->push_front(src);
	return true;
}

bool Scanner::push_back(fs::path const& file, bool squelch) {
	ref_ptr<ScannerFileSource> src = new ScannerFileSource(_config, file, squelch);
	if (!src->good()) return false;
	_sources->push_back(src);
	return true;
}

void Scanner::push_front(char const* buffer, Location const& loc) {
	ref_ptr<ScannerBufferSource> src = new ScannerBufferSource(_config, buffer, loc);
	if (!src->good()) return false;
	_sources->push_front(src);
	return true;
}

void Scanner::push_back(char const* buffer, Location const& loc) {
	ref_ptr<ScannerBufferSource> src = new ScannerBufferSource(_config, buffer, loc);
	if (!src->good()) return false;
	_sources->push_back(src);
	return true;
}


Token* Scanner::readToken() {
	int ret;
	Location begin;

re2c_start:
	token() = cursor();
	begin = loc();

	/*!re2c
		re2c:define:YYCTYPE				= char const;
		re2c:define:YYMARKER			= marker();
		re2c:define:YYCURSOR			= cursor();
		re2c:define:YYLIMIT				= limit();
		re2c:define:YYGETCONDITION		= _cond;
		re2c:define:YYGETCONDITION:naked= 1;
		re2c:define:YYFILL				= fill;
				


		LAN 							= [a-z_];
		AN 								= [a-zA-Z0-9_];
		NUM								= [0-9];
		WS						 		= [ \t\v\f];
		NL						 		= [\n];
		EOF								= [\X0000];

		<NORMAL> NL						{ _line++; _newline = cursor(); 				goto re2c_start; 	}
		<NORMAL> WS						{ 												goto re2c_start; 	}
		<NORMAL> "Answer"				{ ret = T_ANSWER;								goto re2c_finish;	}
		<NORMAL> "UNSATISFIABLE"		{ ret = T_UNSATISFIABLE;						goto re2c_finish;	}
		<NORMAL> "SATISFIABLE"			{ ret = T_SATISFIABLE;							goto re2c_finish;	}
		<NORMAL> "Models"				{ ret = T_MODELS;								goto re2c_finish;	}
		<NORMAL> "Time"					{ ret = T_TIME;									goto re2c_finish;	}
		<NORMAL> "Prepare"				{ ret = T_PREPARE;								goto re2c_finish;	}
		<NORMAL> "Prepro."				{ ret = T_PREPRO_DOT;							goto re2c_finish;	}
		<NORMAL> "Solving"				{ ret = T_SOLVING;								goto re2c_finish;	}
		<NORMAL> NUM+[.]NUM+			{ ret = T_FP_NUMBER;							goto re2c_finish;	}
		<NORMAL> NUM+					{ ret = T_NUMBER;								goto re2c_finish;	}
		<NORMAL> LAN AN*				{ ret = T_ID; 									goto re2c_finish; 	}
		<NORMAL> EOF					{ ret = T_EOF; 									goto re2c_finish; 	}
		<NORMAL> "("					{ ret = T_L_PAREN; 								goto re2c_finish; 	}
		<NORMAL> ")"					{ ret = T_R_PAREN; 								goto re2c_finish; 	}
		<NORMAL> ","					{ ret = T_COMMA; 								goto re2c_finish; 	}
		<NORMAL> "."					{ ret = T_DOT; 									goto re2c_finish; 	}
		<NORMAL> ":"					{ ret = T_COLON;								goto re2c_finish;	}
		<NORMAL> ["]					{ _cond = yycSTRING; 							goto yyc_STRING; 	}
		<NORMAL> "%"					{ _cond = yycCOMMENT; 							goto yyc_COMMENT; 	}


		<STRING> NL						{ _line++; _newline = cursor(); 					goto yyc_STRING; 	}
		<STRING> [\\]["]				{ 												goto yyc_STRING; 	}
		<STRING> ["]					{ _cond = yycNORMAL; ret = T_STRING_LITERAL;	goto re2c_finish;	}
		<STRING> .						{												goto yyc_STRING;	}
		<STRING> EOF					{ ret = T_ERR_UNTERMINATED_STRING;				goto re2c_finish;	}

		<COMMENT> NL					{ _line++; _newline = cursor();					goto re2c_start;	}
		<COMMENT> [^\n]+				{ 												goto yyc_COMMENT;	}
		<COMMENT> EOF					{ ret = T_EOF;									goto re2c_finish;	}


		<*> .							{ ret = T_ERR_UNKNOWN_SYMBOL;					goto re2c_finish;	}

	*/

re2c_finish:
	ReferencedString* str = new ReferencedString();
	str->assign(token(), (size_t)(cursor() - token()));

	_lasttoken() = new Token(ret, str, begin, loc());
	return _lasttoken();
}

void Scanner::close() {
	_sources.clear();
}


}}}
